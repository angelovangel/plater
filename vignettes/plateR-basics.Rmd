---
title: "Getting started with `plateR`"
author: "Sean Hughes"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, echo = FALSE}
# for github flavored markdown, use 
# output:
#   md_document:
#     variant: markdown_github
# then switch back to output: rmarkdown::html_vignette. Just open plateR-basics.md and resave to update time stamp

# print results of code using #>
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```


## File structure 

When you installed `plateR`, several example .csv files were installed. These files have data and metadata from one experiment and we'll use them to illustrate how `plateR` works. Let's look at them briefly to see how the files should be structured. To find out where the files are stored on your computer, run this code.   

```{r}
# get the file path to the folder
library(plateR)
system.file("extdata", package = "plateR")
```

Now, open up the appropriate folder on your computer. You will see three files: 

- all-plates.csv
- bacterial-killing-one-well-per-row.csv
- just-metadata.csv

Open all-data.csv in a spreadsheet application. 

As you can see, the file is formatted as several microtiter plates. The top-left most cell has the name of the information in that plate and the subsequent wells in the top row are labeled 1-12. The subsequent cells in the first column are labeled A-H. Plates are separated by an empty row. This specific example is for a 96-well plate, but for any standard size plate (12-384 wells), the same format applies: plate name top left, numbers along the top row to label columns, letters along the left column to label rows, and an empty row between plates. 

In the top plate, every well is filled, but that's not necessary. Scroll down to the plate labeled Concentration. Here you see the same structure, but some of the wells are empty. Those wells will simply be represented as `NA`. If they're empty in every plate you're using, they'll be omitted.

### Tips for creating files
It's easy and convenient to make plate layouts like this in a spreadsheet program. Just make sure to save them as .csv files. One caution: some spreadsheet programs will include columns in the .csv output if they've ever had text in them, even if they're currently empty. So if you get errors about the plate layout being incorrect, but it looks right to you, try highlighting and deleting 10 columns to the right of the plate and 10 rows under the plate and re-saving the file. 

## Starting from scratch with `read_plate()`
Commonly, an instrument will output data in the form of a plate and that's where you'll want to start. Take this data and copy and paste it into the format described above and save it as a .csv file. `read_plate()` will turn each plate in the file into a column, so add all the metadata you want as more plates below the data plate. 

Below we illustrate getting the file path for the .csv file of interest and then reading it in. Note that we use `system.file()` here to get the file path of the example file installed with the package, but for your own files you would specify the file path relative to the current working directory without using `system.file()`.

```{r}
bk <- system.file("extdata", "all-data.csv", package = "plateR")
   
data <- read_plate(
      file = bk,                    # full path to the .csv file
      well_ids_column = "Wells",    # name to give column of well IDs (optional)
      plate_size = 96               # total number of wells on the plate (optional)
)
str(data)

head(data)
```

To check that the new data frame matched everything up as we expected, we can use `view_plate()`. 

```{r}
# check concentrations column
view_plate( 
      data = data,                         # data frame of interest
      well_ids_column = "Wells",           # name of the column with the well IDs
      column_to_display = "Concentration", # column to display 
      plate_size = 96                      # total number of wells on the plate (optional)
)   

# check sample column
view_plate(data, "Wells", "Sample")
```

# Starting with some data with `add_plate()`
Sometimes instruments give you data in the form you want: one row per well. But with complicated plate layouts, it can be a pain to match up metadata to the appropriate well. That's where `add_plate()` comes in: you take a data frame that already has one well per row and you add columns from a plate-shaped .csv file.

In this case, we'll imagine that the instrument that measured bacterial killing gave a file with one well per row ("bacterial-killing-one-well-per-row.csv"), but that the instrument that measured viability gave us the data in the form of a plate layout as before. We want to add all our metadata (concentration, sample, drug) in plate format for convenience.  

First, read in the data you want to add columns to.

```{r}
bk2 <- system.file("extdata", "bacterial-killing-one-well-per-row.csv", 
  package = "plateR")

data2 <- read.csv(bk2)

str(data2)

head(data2)
```

Now, we want to add the data from the plate layout file to this data frame and match it up by wells. Note that it doesn't matter what order the wells are in in `data2`: In the call to `add_plate` we'll specify which column in `data2` has the well IDs and it'll match it up that way. 

```{r}
meta <- system.file("extdata", "just-metadata.csv", package = "plateR")
data2 <- add_plate(
      file = meta,                # full paths to the .csv files
      data = data2,               # data frame to add to    
      well_ids_column = "Wells",  # name of column of well IDs in data frame
      plate_size = 96             # total number of wells on the plate (optional)
)
str(data2)

head(data2)
```