---
title: "Getting started with `plateR`"
author: "Sean Hughes"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, echo = FALSE}
# for github flavored markdown, use 
# output:
#   md_document:
#     variant: markdown_github
# then switch back to output: rmarkdown::html_vignette. Just open plateR-basics.md and resave to update time stamp

# print results of code using #>
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```


## File structure 

When you installed `plateR`, several example .csv files were installed. These files have data from one experiment and illustrate how `plateR` works. Let's look at them briefly to see how the files should be structured. To find out where the files are stored on your computer, run this code.   

```{r}
# get the file path to the folder
library(plateR)
system.file("extdata", package = "plateR")
```

Now, open up the appropriate folder on your computer. You will see three files: 

- example-1.csv
- example-2-data.csv
- example-2-metadata.csv

Open example-1.csv in a spreadsheet application. 

As you can see, the file is formatted as several microtiter plates. Each plate will be converted to a single column of a data frame. The top-left most cell holds the title to give that column. The subsequent wells in the top row of the plate are labeled 1-12. The subsequent cells in the first column of the plate are labeled A-H. Plates are separated by an empty row. This specific example is for a 96-well plate, but for any standard size plate (12-384 wells), the same format applies: plate name top left, numbers along the top row to label columns, letters along the left column to label rows, and an empty row between plates. 

In the top plate, every well is filled, but that's not necessary. Scroll down to the plate labeled Concentration. Here you see the same structure, but some of the wells are empty. Those wells will simply be represented as `NA`. If they're empty in every plate in the file, they'll be omitted.

### Tips for creating files
It's easy and convenient to make plate layouts like this in a spreadsheet program. Just make sure to save them as .csv files. One caution: some spreadsheet programs will include columns in the .csv output if they've ever had text in them, even if they're currently empty. So if you get errors about the plate layout being incorrect, but it looks right to you, try deleting 10 columns to the right of the plate and 10 rows under the plate and re-saving the file. 

## Approach 1: Starting from scratch with `read_plate()`
Let's say you did the experiment shown in example-1.csv. The instruments measuring bacterial killing and viability gave you data shaped like a plate and you combined them, along with information about what each plate represents, into example-1.csv. But what you really want is a data frame with columns for each variable, matched up by well. `read_plate()` will turn each plate in the file into a column. 

Below we illustrate getting the file path and then reading it in. Note that we use `system.file()` here to get the file path of the example file installed with the package, but for your own files you would specify the file path relative to the current working directory without using `system.file()`.

```{r}
bk <- system.file("extdata", "example-1.csv", package = "plateR")
   
data <- read_plate(
      file = bk,                    # full path to the .csv file
      well_ids_column = "Wells",    # name to give column of well IDs (optional)
      plate_size = 96               # total number of wells on the plate (optional)
)
str(data)

head(data)
```

To check that the new data frame matched everything up as we expected, we can use `view_plate()`. 

```{r}
# check concentrations column
view_plate( 
      data = data,                         # data frame of interest
      well_ids_column = "Wells",           # name of the column with the well IDs
      column_to_display = "Concentration", # column to display 
      plate_size = 96                      # total number of wells on the plate (optional)
)   

# check sample column
view_plate(data, "Wells", "Sample")
```

So, now you have a tidy data frame that's easy to analyze. 

# Approach 2: Starting with some data with `add_plate()`
The above approach works when all of your data are plate-shaped. Sometimes, though, instruments give you data with one row per well, which is what you ultimately want. But you probably think about your experiment in terms of what well was what, and it can be a pain to match up metadata to the appropriate well. That's where `add_plate()` comes in: you combine two spreadsheets: one that has one well per row and another that has plate-shaped data.

Let's imagine you did the same experiment as above, except that the instrument that measured bacterial killing gave a file with one well per row ("example-2-data.csv"), while the instrument that measured viability gave us plate-shaped data like before. We want to add all our metadata (concentration, sample, drug) in plate format for convenience.  

First, read in the bacterial killing data.

```{r}
bk2 <- system.file("extdata", "example-2-data.csv", 
  package = "plateR")

data2 <- read.csv(bk2)

str(data2)

head(data2)
```

Now, we want to combine `data2` with all the plate-shaped data and match it up by well. Note that it doesn't matter what order the wells are in in `data2`: In the call to `add_plate` we'll specify which column in `data2` has the well IDs and it'll match it up that way. 

```{r}
meta <- system.file("extdata", "example-2-metadata.csv", package = "plateR")
data2 <- add_plate(
      file = meta,                # full path to the .csv file
      data = data2,               # data frame to add to    
      well_ids_column = "Wells",  # name of column of well IDs in data frame
      plate_size = 96             # total number of wells on the plate (optional)
)
str(data2)

head(data2)
```

So, now we have a tidy data frame that's easy to analyze. 