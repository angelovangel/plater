---
title: "Getting started with `plateR`"
author: "Sean Hughes"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, echo = FALSE}
# for github flavored markdown, use 
# output:
#   md_document:
#     variant: markdown_github
# then switch back to output: rmarkdown::html_vignette. Just open plateR-basics.md and resave to update time stamp

# print results of code using #>
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## So what's the point? 
You do your experiment in a plate. You think about which wells are which in terms of that plate. Maybe the data even comes out shaped like a plate. 

But that's a terrible shape for data analysis. You want one well per row. Trying to match up your mental picture of the plate to a column of well IDs is a huge pain though. The point of `plateR` is to let you store your data shaped like a plate and then turn it into a tidy form for data analysis effortlessly.

## An example
You do an experiment. Your data look like this: 

```{r, echo = FALSE}
library(plateR)
bk <- system.file("extdata", "example-1.csv", package = "plateR")
   
data <- read_plate(bk)

view_plate(data, "Wells", "BacterialKilling")
```

Each sample got treated with a drug, in this pattern: 

```{r, echo=FALSE}
data$Treatment <- gsub("Drug ", "", data$Treatment)
data$Treatment <- gsub("Control", "Ctrl", data$Treatment)

view_plate(data, "Wells", "Treatment")
```

When you analyze it, you want it to look like this: 

```{r, echo=FALSE}
head(data[, c("Wells", "BacterialKilling", "Treatment")])
```

`plateR` makes that effortless.

## File structure: `plateR` format 
Let's get started.

When you installed `plateR`, several example .csv files were installed. These files illustrate how `plateR` format files should be formatted. To find out where the files are stored on your computer, run this code.   

```{r}
# get the file path to the folder
library(plateR)
system.file("extdata", package = "plateR")
```

Now, open up the appropriate folder on your computer. You will see three files: 

- `example-1.csv`
- `example-2-data.csv`
- `example-2-metadata.csv`

Open `example-1.csv` in a spreadsheet application. As you can see, the file is formatted as several microtiter plates. The important features of `plateR` format are: 

- Top-left most cell of each plate holds the name of the plate (to be used as the column title after conversion to a data frame)
- The rest of the top row is labeled 1-12. 
- The rest of the first column is labeled A-H. 
- Plates are separated by an empty row. 

Wells can be empty. In the top plate, every well is filled. Scroll down to the plate labeled Concentration. Here you see the same structure, but some of the wells are empty. Those wells will be represented as `NA`. If they're empty in every plate in the file, they'll be omitted.

The examples are 96-well, but any standard size plate (12-384 wells) can be used in `plateR` format: plate name top left, numbers along the top row to label columns, letters along the left column to label rows, and an empty row between plates. 

### Tips for creating files
It's easy and convenient to make `plateR` format files in a spreadsheet program. Just make sure to save them as .csv files. 

One caution: some spreadsheet programs will include columns in the .csv output if they've ever had text in them, even if they're currently empty. So if you get errors about the plate layout being incorrect, but it looks right to you, try deleting 10 columns to the right of the plate and 10 rows under the plate and re-saving the file. 

## Approach 1: Starting from scratch with `read_plate()`
Let's say you did the experiment shown in `example-1.csv`. The instruments measuring bacterial killing and viability gave you data shaped like a plate and you combined them, along with information about what each plate represents, into `example-1.csv`. 

But what you really want is a data frame with columns for each variable, matched up by well. That's what `read_plate()` is for. 

```{r}
bk <- system.file("extdata", "example-1.csv", package = "plateR")
   
data <- read_plate(
      file = bk,                    # full path to the .csv file
      well_ids_column = "Wells",    # name to give column of well IDs (optional)
      plate_size = 96               # total number of wells on the plate (optional)
)
str(data)

head(data)
```

Note that we use `system.file()` here to get the file path of the example file installed with the package, but for your own files you would specify the file path relative to the current working directory without using `system.file()`.

So, now you're done: you have a tidy data frame that's easy to analyze. 

## Approach 2: Combine two files with `add_plate()`
The above approach works when all of your data are plate-shaped. Sometimes, though, instruments give you data with one row per well. But you probably think about your experiment in terms of what well was what, and it can be a pain to figure out just from the well ID. That's where `add_plate()` comes in: you combine two spreadsheets: one that has one well per row and another that has plate-shaped data.

Let's imagine you did the same experiment as above, except that the instrument that measured bacterial killing gave a file with one well per row (`example-2-data.csv`), while the instrument that measured viability gave us plate-shaped data like before (`example-2-metadata.csv`). In the second file, you also have the data labeling what well was what (concentration, sample, drug).

You want to combine those two files, matching up the wells. 

First, read in the bacterial killing data.

```{r}
bk2 <- system.file("extdata", "example-2-data.csv", 
  package = "plateR")

data2 <- read.csv(bk2)

str(data2)

head(data2)
```

Now, you want to combine `data2` with all the plate-shaped data and match it up by well. That's where `add_plate()` comes in. It takes a .csv file in `plateR` format and combines it with a one-well-per-row data frame. 

```{r}
meta <- system.file("extdata", "example-2-metadata.csv", package = "plateR")
data2 <- add_plate(
      file = meta,                # full path to the .csv file
      data = data2,               # data frame to add to    
      well_ids_column = "Wells",  # name of column of well IDs in data frame
      plate_size = 96             # total number of wells on the plate (optional)
)
str(data2)

head(data2)
```

Note that it doesn't matter what order the wells are in in `data2`: In the call to `add_plate()` the column in `data2` with the well IDs is specified and it'll match it up using the well IDs. 

So, now you're done: you have a tidy data frame that's easy to analyze. 

## Seeing is believing
Sometimes it's useful to look at data as though it's back on the plate. That's where `view_plate()` comes in. 

```{r}
view_plate( 
      data = data2,                         # data frame of interest
      well_ids_column = "Wells",           # name of the column with the well IDs
      column_to_display = "Concentration", # column to display 
      plate_size = 96                      # total number of wells on the plate (optional)
)   
```